import itertools

class Solution:
    def countAndSay(self, n: int) -> str:
        """
        Generates the nth term of the count-and-say sequence.

        The sequence starts with "1". Each subsequent term is generated by
        describing the previous term in terms of counts of consecutive digits.

        Args:
            n: The index (1-based) of the term to generate.

        Returns:
            The nth term of the count-and-say sequence as a string.
        """
        if n == 1:
            return "1"

        # Start with the first term
        current_sequence = "1"

        # Iterate n-1 times to reach the nth term
        for _ in range(n - 1):
            next_sequence = []
            i = 0
            while i < len(current_sequence):
                # Current character to count
                char = current_sequence[i]
                count = 0
                # Count consecutive occurrences of the character
                while i < len(current_sequence) and current_sequence[i] == char:
                    count += 1
                    i += 1
                # Append the count and the character to the next sequence
                next_sequence.append(str(count))
                next_sequence.append(char)
            # Join the parts to form the next sequence string
            current_sequence = "".join(next_sequence)

        return current_sequence

# Example Usage:
sol = Solution()

# Example 1:
n1 = 4
output1 = sol.countAndSay(n1)
print(f"Input: n = {n1}")
print(f"Output: \"{output1}\"") # Expected: "1211"

# Example 2:
n2 = 1
output2 = sol.countAndSay(n2)
print(f"Input: n = {n2}")
print(f"Output: \"{output2}\"") # Expected: "1"

# Another example
n3 = 5
output3 = sol.countAndSay(n3)
# countAndSay(1) = "1"
# countAndSay(2) = "11"
# countAndSay(3) = "21"
# countAndSay(4) = "1211"
# countAndSay(5) = RLE of "1211" -> one 1, one 2, two 1s -> "111221"
print(f"Input: n = {n3}")
print(f"Output: \"{output3}\"") # Expected: "111221"

# Alternative using itertools.groupby (more concise but potentially less intuitive for beginners)
class SolutionItertools:
     def countAndSay(self, n: int) -> str:
        s = '1'
        for _ in range(n - 1):
            # Group consecutive identical characters and generate the next string
            # groupby returns the character (key) and an iterator for the group
            # ''.join(...) concatenates the count and character for each group
            s = ''.join(str(len(list(group))) + key for key, group in itertools.groupby(s))
        return s

# Example Usage (Itertools):
sol_it = SolutionItertools()
print("\nUsing itertools.groupby:")
print(f"Input: n = 4, Output: \"{sol_it.countAndSay(4)}\"") # Expected: "1211"
print(f"Input: n = 5, Output: \"{sol_it.countAndSay(5)}\"") # Expected: "111221"